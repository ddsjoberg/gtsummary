<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Pack and unpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for pack {tidyr}"><tr><td>pack {tidyr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Pack and unpack</h2>

<h3>Description</h3>

<a href='https://www.tidyverse.org/lifecycle/#maturing'><img src='figures/lifecycle-maturing.svg' alt='Maturing lifecycle'></a>
<p>Packing and unpacking preserve the length of a data frame, changing its
width. <code>pack()</code> makes <code>df</code> narrow by collapsing a set of columns into a
single df-column. <code>unpack()</code> makes <code>data</code> wider by expanding df-columns
back out into individual columns.
</p>


<h3>Usage</h3>

<pre>
pack(data, ...)

unpack(data, cols, names_sep = NULL, names_repair = "check_unique")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Name-variable pairs of the form <code>new_col = c(col1, col2, col3)</code>,
that describe how you wish to pack existing columns into new columns.
The right hand side can be any expression supported by tidyselect.</p>
</td></tr>
<tr valign="top"><td><code>cols</code></td>
<td>
<p>Name of column that you wish to unpack.</p>
</td></tr>
<tr valign="top"><td><code>names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names of new columns will
come directly from the inner data frame.
</p>
<p>If a string, the names of the new columns will be formed by pasting
together the outer column name with the inner names, separated by
<code>names_sep</code>.</p>
</td></tr>
<tr valign="top"><td><code>names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li><p> &quot;minimal&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li><p> &quot;unique&quot;: make sure names are unique and not empty,
</p>
</li>
<li><p> &quot;check_unique&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li><p> &quot;universal&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr_legacy.html">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="../../rlang/html/as_function.html">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="../../vctrs/html/vec_as_names.html">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, unpacking is more useful than packing because it simplifies
a complex data structure. Currently, few functions work with df-cols,
and they are mostly a curiosity, but seem worth exploring further because
they mimic the nested column headers that are so popular in Excel.
</p>


<h3>Examples</h3>

<pre>
# Packing =============================================================
# It's not currently clear why you would ever want to pack columns
# since few functions work with this sort of data.
df &lt;- tibble(x1 = 1:3, x2 = 4:6, x3 = 7:9, y = 1:3)
df
df %&gt;% pack(x = starts_with("x"))
df %&gt;% pack(x = c(x1, x2, x3), y = y)

# Unpacking ===========================================================
df &lt;- tibble(
  x = 1:3,
  y = tibble(a = 1:3, b = 3:1),
  z = tibble(X = c("a", "b", "c"), Y = runif(3), Z = c(TRUE, FALSE, NA))
)
df
df %&gt;% unpack(y)
df %&gt;% unpack(c(y, z))
df %&gt;% unpack(c(y, z), names_sep = "_")
</pre>

<hr /><div style="text-align: center;">[Package <em>tidyr</em> version 0.8.99.9000 <a href="00Index.html">Index</a>]</div>
</body></html>
